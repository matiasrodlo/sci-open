import dotenv from 'dotenv';
import path from 'path';
import { fileURLToPath } from 'url';

// Load .env from workspace root
// Handle both ESM (dev with tsx) and CommonJS (production build)
let __dirname_esm: string;
if (typeof __dirname === 'undefined') {
  const __filename_esm = fileURLToPath(import.meta.url);
  __dirname_esm = path.dirname(__filename_esm);
} else {
  __dirname_esm = __dirname;
}
dotenv.config({ path: path.resolve(__dirname_esm, '../../../.env') });

import Fastify from 'fastify';
import cors from '@fastify/cors';
import helmet from '@fastify/helmet';
import { SearchParams, SearchResponse, PaperResponse, OARecord } from '@open-access-explorer/shared';
// Temporarily disable search adapters to avoid Typesense crashes
// import { TypesenseAdapter, MeilisearchAdapter, AlgoliaAdapter } from '@open-access-explorer/search';
import { ArxivConnector } from './sources/arxiv';
import { CoreConnector } from './sources/core';
import { EuropePMCConnector } from './sources/europepmc';
import { NCBIConnector } from './sources/ncbi';
import { BiorxivConnector } from './sources/biorxiv';
import { OpenAIREConnector } from './sources/openaire';
import { PLOSConnector } from './sources/plos';
import { UnpaywallConnector } from './sources/unpaywall';
import { CrossrefEnricher } from './sources/crossref';
import { DOAJConnector } from './sources/doaj';
import { SearchPipeline } from './lib/search-pipeline';
import { resolveBestPdf } from './lib/pdf';
import { getSearchCache, getPaperCache, generateCacheKey } from './lib/cache';

const fastify = Fastify({
  logger: {
    level: process.env.NODE_ENV === 'production' ? 'info' : 'debug'
  }
});

// Register plugins
fastify.register(cors, {
  origin: process.env.NODE_ENV === 'production' ? false : true,
  credentials: true
});

fastify.register(helmet);

// Use mock search adapter (Typesense disabled for now)
console.log('Using mock search adapter - Typesense disabled');
const searchAdapter = {
  search: async () => ({ hits: [], facets: {}, total: 0 }),
  ensureIndex: async () => {},
  upsertMany: async () => {}
};

// Initialize source connectors
const arxivConnector = new ArxivConnector(process.env.ARXIV_BASE);
const coreConnector = new CoreConnector(process.env.CORE_BASE, process.env.CORE_API_KEY || '');
const europepmcConnector = new EuropePMCConnector(process.env.EUROPE_PMC_BASE);
const ncbiConnector = new NCBIConnector(process.env.NCBI_EUTILS_BASE, process.env.NCBI_API_KEY);
const biorxivConnector = new BiorxivConnector(process.env.BIORXIV_BASE);
const openaireConnector = new OpenAIREConnector(process.env.OPENAIRE_BASE);
const plosConnector = new PLOSConnector(process.env.PLOS_BASE);
const unpaywallConnector = new UnpaywallConnector(process.env.UNPAYWALL_EMAIL || 'your-email@example.com');
const doajConnector = new DOAJConnector(process.env.DOAJ_BASE, process.env.DOAJ_API_KEY);
const crossrefEnricher = new CrossrefEnricher(process.env.UNPAYWALL_EMAIL || 'your-email@example.com');

// Initialize search pipeline
const userAgent = `OpenAccessExplorer/1.0 (mailto:${process.env.UNPAYWALL_EMAIL || 'your-email@example.com'})`;
const searchPipeline = new SearchPipeline({
  userAgent,
  maxResults: 100,
  enableEnrichment: true,
  enablePdfResolution: true,
  enableCitations: false
});

// Ensure search index exists (optional - will fall back to direct queries if fails)
searchAdapter.ensureIndex().catch((error) => {
  console.log('Search backend not available, will use direct source queries:', error.message);
});

// Helper function to distribute results across sources
function distributeResultsAcrossSources(results: any[], pageSize: number): any[] {
  // Group results by source
  const bySource = results.reduce((acc, result) => {
    if (!acc[result.source]) acc[result.source] = [];
    acc[result.source].push(result);
    return acc;
  }, {} as Record<string, any[]>);

  const sources = Object.keys(bySource);
  const distributed: any[] = [];
  
  // Round-robin distribution across sources
  let sourceIndex = 0;
  while (distributed.length < pageSize && sources.length > 0) {
    const currentSource = sources[sourceIndex % sources.length];
    const sourceResults = bySource[currentSource];
    
    if (sourceResults.length > 0) {
      distributed.push(sourceResults.shift()!);
    } else {
      // Remove empty sources
      sources.splice(sourceIndex % sources.length, 1);
      if (sources.length === 0) break;
      sourceIndex = sourceIndex % sources.length;
      continue;
    }
    
    sourceIndex++;
  }
  
  return distributed;
}

// Search endpoint
fastify.post<{ Body: SearchParams }>('/api/search', async (request, reply) => {
  try {
    const params = request.body;
    const cacheKey = generateCacheKey('search', params);
    const searchCache = getSearchCache();
    
    // Check cache first
    const cached = searchCache.get<SearchResponse>(cacheKey);
    if (cached) {
      fastify.log.info({ cacheKey, query: params.q }, 'Returning cached search results');
      reply.header('Cache-Control', 'public, max-age=300');
      return cached;
    }
    
    fastify.log.info({ cacheKey, query: params.q }, 'No cache hit, performing fresh search');

    // Use the new search pipeline
    const searchResult = await searchPipeline.search(params);

    // Cache the result
    searchCache.set(cacheKey, searchResult, 300000); // 5 minutes
    reply.header('Cache-Control', 'public, max-age=300');
    
    fastify.log.info({ 
      totalResults: searchResult.total,
      query: params.q 
    }, 'Search pipeline completed');
    
    return searchResult;

  } catch (error: any) {
    reply.code(500);
    return { error: error.message };
  }

    // Try search backend first, but gracefully handle failures
    try {
      searchResult = await searchAdapter.search({
        q: params.q,
        filters: params.filters,
        page: params.page || 1,
        pageSize: params.pageSize || 20,
        sort: params.sort || 'relevance'
      });
    } catch (searchError) {
      fastify.log.warn({ error: searchError }, 'Search backend unavailable, falling back to direct source queries');
      // Continue with empty search result - we'll query sources directly
    }

    // Always try remote sources when we have a query (since search backend is not available)
    if (params.q || params.doi) {
      fastify.log.info({ query: params.q || params.doi }, 'Querying remote sources');
      console.log('üîç About to query remote sources for:', params.q);
      
      const searchParams = {
        titleOrKeywords: params.q,
        doi: params.doi,
        yearFrom: params.filters?.yearFrom,
        yearTo: params.filters?.yearTo
      };

      // PERFORMANCE OPTIMIZATION: Add timeout wrapper to prevent slow sources from blocking
      const withTimeout = <T,>(promise: Promise<T>, timeoutMs: number): Promise<T> => {
        return Promise.race([
          promise,
          new Promise<T>((_, reject) => 
            setTimeout(() => reject(new Error('Source timeout')), timeoutMs)
          )
        ]);
      };

        const remoteResults = await Promise.allSettled([
          withTimeout(arxivConnector.search(searchParams), 10000),    // 10s timeout
          withTimeout(coreConnector.search(searchParams), 10000),      // 10s timeout
          withTimeout(europepmcConnector.search(searchParams), 10000), // 10s timeout
          withTimeout(ncbiConnector.search(searchParams), 10000),      // 10s timeout
          withTimeout(biorxivConnector.search(searchParams), 10000),   // 10s timeout
          withTimeout(openaireConnector.search(searchParams), 10000),  // 10s timeout
          withTimeout(plosConnector.search(searchParams), 10000),      // 10s timeout
          withTimeout(doajConnector.search(searchParams), 10000)       // 10s timeout
        ]);

        // Log results from each source
        const sourceNames = ['arxiv', 'core', 'europepmc', 'ncbi', 'biorxiv/medrxiv', 'openaire', 'plos', 'doaj'];
        remoteResults.forEach((result, index) => {
          const sourceName = sourceNames[index];
          if (result.status === 'fulfilled') {
            fastify.log.info({ 
              source: sourceName, 
              count: result.value.length 
            }, 'Source search completed');
          } else {
            fastify.log.warn({ 
              source: sourceName, 
              error: result.reason?.message || 'Unknown error' 
            }, 'Source search failed');
          }
        });

        const allRemoteResults = remoteResults
          .filter(result => result.status === 'fulfilled')
          .flatMap(result => (result as PromiseFulfilledResult<any>).value);

      
      fastify.log.info({ 
        totalBefore: allRemoteResults.length,
        bySources: {
          arxiv: allRemoteResults.filter(r => r.source === 'arxiv').length,
          core: allRemoteResults.filter(r => r.source === 'core').length,
          europepmc: allRemoteResults.filter(r => r.source === 'europepmc').length,
          ncbi: allRemoteResults.filter(r => r.source === 'ncbi').length,
          doaj: allRemoteResults.filter(r => r.source === 'doaj').length,
        }
      }, 'Results before deduplication');

      // Deduplicate by DOI, but try to keep source diversity
      // Group by DOI/title, then pick one representative from each group
      const paperGroups = new Map<string, OARecord[]>();
      
      for (const record of allRemoteResults) {
        let key: string;
        if (record.doi) {
          key = `doi:${record.doi}`;
        } else {
          key = `title:${record.title.toLowerCase()}`;
        }
        
        if (!paperGroups.has(key)) {
          paperGroups.set(key, []);
        }
        paperGroups.get(key)!.push(record);
      }
      
      // For each group, prefer the first occurrence BUT ensure we have
      // at least some representation from each source
      const uniqueResults: OARecord[] = [];
      const sourcePreference = ['arxiv', 'ncbi', 'europepmc', 'core'];
      
      for (const [key, group] of paperGroups.entries()) {
        if (group.length === 1) {
          uniqueResults.push(group[0]);
        } else {
          // Multiple sources have this paper - prefer in source order
          // but keep the first one found
          const sorted = group.sort((a, b) => {
            const aIndex = sourcePreference.indexOf(a.source);
            const bIndex = sourcePreference.indexOf(b.source);
            return aIndex - bIndex;
          });
          uniqueResults.push(sorted[0]);
        }
      }
      
      fastify.log.info({ 
        totalAfter: uniqueResults.length,
        bySources: {
          arxiv: uniqueResults.filter(r => r.source === 'arxiv').length,
          core: uniqueResults.filter(r => r.source === 'core').length,
          europepmc: uniqueResults.filter(r => r.source === 'europepmc').length,
          ncbi: uniqueResults.filter(r => r.source === 'ncbi').length,
          openaire: uniqueResults.filter(r => r.source === 'openaire').length,
          doaj: uniqueResults.filter(r => r.source === 'doaj').length,
        },
        duplicateGroups: paperGroups.size,
        totalRecords: allRemoteResults.length
      }, 'Results after deduplication');

      // PERFORMANCE OPTIMIZATION: Skip enrichment entirely for faster response
      // Enrichment can be done asynchronously after returning results
      // OR only enrich the paginated results that will be shown to the user
      
      // This dramatically improves search response time from 27s to <3s

      // Apply client-side filters
      let filteredResults = uniqueResults;
      
      // CRITICAL: Filter to only include papers with PDFs (free full text)
      // This ensures facets and total count match what's actually displayed
      filteredResults = filteredResults.filter(record => record.bestPdfUrl);
      
      if (params.filters) {
        // Filter by source
        if (params.filters.source && params.filters.source.length > 0) {
          filteredResults = filteredResults.filter(record => 
            params.filters!.source!.includes(record.source)
          );
        }
        
        // Filter by specific years (if provided as array)
        // @ts-ignore - year can be passed as string[] for exact matches
        if (params.filters.year && Array.isArray(params.filters.year) && params.filters.year.length > 0) {
          // @ts-ignore
          const yearNumbers = params.filters.year.map((y: string) => parseInt(y));
          filteredResults = filteredResults.filter(record => 
            record.year && yearNumbers.includes(record.year)
          );
        }
        // Otherwise filter by year range
        else if (params.filters.yearFrom || params.filters.yearTo) {
          filteredResults = filteredResults.filter(record => {
            if (!record.year) return false;
            if (params.filters!.yearFrom && record.year < params.filters!.yearFrom) return false;
            if (params.filters!.yearTo && record.year > params.filters!.yearTo) return false;
            return true;
          });
        }
        
        // Filter by oaStatus
        if (params.filters.oaStatus && params.filters.oaStatus.length > 0) {
          filteredResults = filteredResults.filter(record => 
            record.oaStatus && params.filters!.oaStatus!.includes(record.oaStatus)
          );
        }
        
        // Filter by venue
        if (params.filters.venue && params.filters.venue.length > 0) {
          filteredResults = filteredResults.filter(record => 
            record.venue && params.filters!.venue!.includes(record.venue)
          );
        }
      }

      // Sort results based on sort parameter
      const sortedResults = [...filteredResults];
      if (params.sort === 'date') {
        sortedResults.sort((a, b) => {
          const dateA = new Date(a.createdAt || a.updatedAt || 0).getTime();
          const dateB = new Date(b.createdAt || b.updatedAt || 0).getTime();
          return dateB - dateA; // Newest first
        });
      }
      // For 'relevance' or default, keep original order from sources

      // Add to search index asynchronously (if backend is available)
      if (uniqueResults.length > 0) {
        searchAdapter.upsertMany(uniqueResults).catch((error: any) => {
          fastify.log.warn({ error }, 'Failed to index results');
        });
      }

      // Implement pagination for fallback mode
      const pageSize = params.pageSize || 20;
      const page = params.page || 1;
      const startIndex = (page - 1) * pageSize;
      const endIndex = startIndex + pageSize;
      
      // Get the slice of results for this page
      const paginatedResults = sortedResults.slice(startIndex, endIndex);
      
      // PERFORMANCE OPTIMIZATION: Skip enrichment for instant response
      // Enrichment adds 20-30 seconds - too slow for user experience
      // TODO: Implement background enrichment or client-side lazy enrichment
      
      fastify.log.info('Skipping enrichment for fast response (instant results)');
      
      searchResult.hits = paginatedResults;
      searchResult.total = sortedResults.length;
      
      // Generate basic facets from ALL sorted results (not just the paginated ones)
      // Don't show numbers - just indicate if source has results
      const formatCount = (count: number, source?: string) => {
        // Just return empty string to hide all numbers
        return '';
      };
      
      searchResult.facets = {
        source: Object.fromEntries(
          Object.entries(sortedResults.reduce((acc, record) => {
            acc[record.source] = (acc[record.source] || 0) + 1;
            return acc;
          }, {} as Record<string, number>)).map(([key, count]) => [key, formatCount(count, key)])
        ),
        year: Object.fromEntries(
          Object.entries(sortedResults.reduce((acc, record) => {
            if (record.year) {
              acc[record.year] = (acc[record.year] || 0) + 1;
            }
            return acc;
          }, {} as Record<string, number>)).map(([key, count]) => [key, formatCount(count)])
        ),
        oaStatus: Object.fromEntries(
          Object.entries(sortedResults.reduce((acc, record) => {
            if (record.oaStatus) {
              acc[record.oaStatus] = (acc[record.oaStatus] || 0) + 1;
            }
            return acc;
          }, {} as Record<string, number>)).map(([key, count]) => [key, formatCount(count)])
        ),
        venue: Object.fromEntries(
          Object.entries(sortedResults.reduce((acc, record) => {
            if (record.venue) {
              acc[record.venue] = (acc[record.venue] || 0) + 1;
            }
            return acc;
          }, {} as Record<string, number>)).map(([key, count]) => [key, formatCount(count)])
        )
      };
      
      fastify.log.info({ 
        totalResults: uniqueResults.length,
        facets: searchResult.facets 
      }, 'Generated facets from search results');
    }

    const response: SearchResponse = {
      hits: searchResult.hits,
      facets: searchResult.facets,
      page: params.page || 1,
      total: searchResult.total,
      pageSize: params.pageSize || 20
    };

    // Cache the result
    searchCache.set(cacheKey, response);

    reply.header('Cache-Control', 'public, max-age=300');
    return response;
  } catch (error) {
    fastify.log.error(error);
    reply.code(500);
    return { error: 'Internal server error' };
  }
});

// Paper endpoint
fastify.get<{ Params: { id: string } }>('/api/paper/:id', async (request, reply) => {
  try {
    const { id } = request.params;
    const cacheKey = generateCacheKey('paper', { id });
    const paperCache = getPaperCache();
    
    // Check cache first
    const cached = paperCache.get<PaperResponse>(cacheKey);
    if (cached) {
      reply.header('Cache-Control', 'public, max-age=600');
      return cached;
    }

    // Try to find the record in search index first
    let record: OARecord | undefined;
    try {
      const searchResult = await searchAdapter.search({
        q: `id:${id}`,
        pageSize: 1
      });
      record = searchResult.hits[0];
    } catch (error) {
      // If not found in index, create a record from the ID
      const [source, sourceId] = id.split(':');
      if (source && sourceId) {
        // Create a basic record with known PDF URL
        record = {
          id,
          source: source as OARecord['source'],
          sourceId,
          title: 'Unknown',
          authors: [],
          createdAt: new Date().toISOString()
        };
        
        // Construct PDF URLs based on source
        if (source === 'arxiv') {
          // arXiv PDF URLs use the full ID including version (e.g., 2409.12922v1)
          record.bestPdfUrl = `https://arxiv.org/pdf/${sourceId}`;
          record.landingPage = `https://arxiv.org/abs/${sourceId}`;
        } else if (source === 'europepmc') {
          // Europe PMC PDF URLs
          if (sourceId.startsWith('PMC')) {
            record.bestPdfUrl = `https://europepmc.org/articles/${sourceId}?pdf=render`;
          } else {
            record.bestPdfUrl = `https://europepmc.org/article/MED/${sourceId}?pdf=render`;
          }
          record.landingPage = `https://europepmc.org/article/${sourceId}`;
        }
      }
    }

    if (!record) {
      reply.code(404);
      return { error: 'Paper not found' };
    }

    // Resolve PDF URL
    let pdfUrl: string | null = null;
    let pdfStatus: "ok" | "not_found" | "error" = "not_found";
    
    // For Europe PMC, NCBI, and OpenAIRE, always prefer the bestPdfUrl from the source
    // These URLs serve HTML pages with PDF embeds or landing pages and don't validate as direct PDFs
    if ((record.source === 'europepmc' || record.source === 'ncbi' || record.source === 'openaire') && record.bestPdfUrl) {
      pdfUrl = record.bestPdfUrl;
      pdfStatus = 'ok';
    } 
    // For other sources, try to validate the PDF
    else {
      pdfUrl = await resolveBestPdf(record);
      
      // If validation failed but we have a bestPdfUrl, use it anyway
      if (!pdfUrl && record.bestPdfUrl) {
        pdfUrl = record.bestPdfUrl;
        pdfStatus = 'ok'; // Assume it's valid since it came from the source
      } else if (pdfUrl) {
        pdfStatus = 'ok';
      }
    }
    
    const response: PaperResponse = {
      record,
      pdf: {
        url: pdfUrl || undefined,
        status: pdfStatus
      }
    };

    // Cache the result
    paperCache.set(cacheKey, response);

    reply.header('Cache-Control', 'public, max-age=600');
    return response;
  } catch (error) {
    fastify.log.error(error);
    reply.code(500);
    return { error: 'Internal server error' };
  }
});

// Health check
fastify.get('/health', async (request, reply) => {
  return { status: 'ok', timestamp: new Date().toISOString() };
});

// Debug endpoint to test source connectors
fastify.get('/debug/sources', async (request, reply) => {
  try {
    const testParams = { titleOrKeywords: 'ai' };
    
    const results = await Promise.allSettled([
      arxivConnector.search(testParams),
      europepmcConnector.search(testParams),
      coreConnector.search(testParams),
      ncbiConnector.search(testParams),
      biorxivConnector.search(testParams),
      openaireConnector.search(testParams),
      plosConnector.search(testParams)
    ]);

    return {
      arxiv: results[0].status === 'fulfilled' ? results[0].value.length : results[0].reason?.message,
      europepmc: results[1].status === 'fulfilled' ? results[1].value.length : results[1].reason?.message,
      core: results[2].status === 'fulfilled' ? results[2].value.length : results[2].reason?.message,
      ncbi: results[3].status === 'fulfilled' ? results[3].value.length : results[3].reason?.message,
      'biorxiv/medrxiv': results[4].status === 'fulfilled' ? results[4].value.length : results[4].reason?.message,
      openaire: results[5].status === 'fulfilled' ? results[5].value.length : results[5].reason?.message,
      plos: results[6].status === 'fulfilled' ? results[6].value.length : results[6].reason?.message,
    };
  } catch (error: any) {
    reply.code(500);
    return { error: error.message };
  }
});

// Start server
const start = async () => {
  try {
    const port = parseInt(process.env.PORT || '4000');
    await fastify.listen({ port, host: '0.0.0.0' });
    console.log(`Server listening on port ${port}`);
  } catch (err) {
    fastify.log.error(err);
    process.exit(1);
  }
};

start();
